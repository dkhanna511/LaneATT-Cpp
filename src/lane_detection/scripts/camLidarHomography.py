#############################################################
# Transform of lane pixels from camera frame to LIDAR frame #
#############################################################

import numpy as np
import fitPlane as fP
import pcl
import matplotlib.pyplot as plt
import cv2
import transforms

def linePlaneIntersection(pLine, qLine, planeCoeffs):
    tDenom = planeCoeffs[0]*(qLine[0]-pLine[0]) + planeCoeffs[1]*(qLine[1] - pLine[1]) + planeCoeffs[2]*(qLine[2] - pLine[2])
    
    if tDenom == 0:
        return 0
    else:
        t = -(planeCoeffs[0]*pLine[0] + planeCoeffs[1]*pLine[1] + planeCoeffs[2]*pLine[2] + planeCoeffs[3]) / tDenom
        return [pLine[0]+t*(qLine[0]-pLine[0]), pLine[1]+t*(qLine[1]-pLine[1]), pLine[2]+t*(qLine[2]-pLine[2])]


def getPtsOnLidar(lidarPtCloud, lanePixCoords, R_, K, T):
    # lidarPtCloud is the pointcloud generated by the LIDAR
    # laneMask is the image which has lane pixels as 1 and rest as zero
    # R, T -> Transform from LIDAR to camera
    # K    -> Intrinsic camera matrix

    #lanePixCoords = [] # set of (x,y) points (x-> column, y-> row)

    R = T[0:3,0:3]
    t = T[0:3, 3]

    # print(np.unique(laneMask))
    # cv2.imshow("LANE MASK", laneMask*255)
    

    # get the 3D rays from the camera
    camRays = np.dot(np.linalg.inv(K), np.array(lanePixCoords).T).T
    # print(camRays)
    # camRays = np.dot(np.linalg.inv(K), np.dot(np.linalg.inv(R_), np.array(lanePixCoords).T)).T
    # print(f'CamRays are: {camRays.shape}')
    # print(F'CamRays are: {camRays}')
    lidarRays = []
    
    # transform the rays from camera frame to LIDAR frame

    # print(f"Camera to LIDAR transformation is: {np.linalg.inv(R), -np.dot(np.linalg.inv(R),t) }")
    # print(f"Lidar to Camera transformation is: {R, t}")

    for i in range(camRays.shape[0]):   
        lidarRay = np.dot(np.linalg.inv(R), camRays[i]) - np.dot(np.linalg.inv(R),t)
        lidarRay = lidarRay#/np.linalg.norm(lidarRay)
        lidarRays.append(lidarRay.tolist())


    lidarRays = np.array(lidarRays)
    # print(f'Lidar Rays are: {lidarRays.shape}')

    # get plane in Lidar Frame of reference
    roadPlane, planeCoeffs   = fP.fitPlane(pcl.PointCloud(lidarPtCloud.astype('float32')), 2.0) 
    print("type roadPlane :{}".format(type(roadPlane)))
    # print(f"planeCoeffs norm is: {np.linalg.norm(planeCoeffs[0:3])}")

    # now determine the intersection points of each lidar ray (or line originating from Lidar with this plane)
    # for each lidar ray -> we have two points [[0,0,0], [ray1, ray2, ray3]]
    lanePts = []
    
    for pt in lidarRays:
    
    # pLine = np.dot(np.linalg.inv(R),t).tolist()
        pLine  = [0,0,0]
        qLine  = pt.tolist()#(pt/np.linalg.norm(pt)).tolist()
        ptLane = linePlaneIntersection(pLine, qLine, planeCoeffs)
        lanePts.append(ptLane)
       # print(f"Intersection Point is: {ptLane}") 
    
    lanePts = np.array(lanePts)

    return lanePts
